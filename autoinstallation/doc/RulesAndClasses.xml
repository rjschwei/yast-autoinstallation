
<chapter id="rulesandclass">
    <title>Rules and Classes</title>
  <section id="rules">
    <title>Rule based auto-installation</title>
    <para>
      Rules offer the possibility to configure a system depending on system
      attributes by merging multiple control file during installation. The
      rules based installation is controlled by a rules file.
    </para>
    <para>
      The rules file is an XML based file that contains
      rules for each group of systems (or single systems) that you want to
      automatically install. A set of rules distinguish a group of systems based on
      one or more system attributes, after passing all rules, it links each
      group of rules to a profile. Both the rules file and the profiles must be
      located in a pre-defined and accessible location.
    </para>
    <para>
        The rules file is retrieved only if no specific control is supplied
        using the <emphasis>autoyast</emphasis> keyword. For example, if the
        following is used, the rules file wont be evaluated:
    </para>
    <screen>
        autoyast=http://10.10.0.1/profile/test.xml
    </screen>
    <figure id="rules_fig1">
      <title id="rules_fig1.title" >Rules</title>
      <mediaobject>&rules;</mediaobject>
    </figure>
    <para>
      If more than one rule apply, the final profile for each group is generated
      on the fly using a merge script. The merging process is based on the
      order of the rules and later rules override configuration data in earlier rules.
    </para>
    <para>
      The use of  a rules file is optional. If the rules file is not found,
      system installation proceeds in the 
      classic way by just using the supplied profile or by searching for the
      profile depending on the <emphasis>MAC</emphasis> or the
      <emphasis>IP</emphasis> address of the system.     
    </para>
<!--
    <para>
      In the previous scenario, you would create a rules file with two different
      rules, one rule for the development and another rule for the sales
      department. For each rule, you could use different system parameters to
      distinguish the groups from one another: the development department has SMP
      and SCI  based systems and the sales group has IDE based systems. Each rule
      would also contain a link to an appropriate profile. For example, in the
      rule for the development department, you would add a link to the profile, called
      <filename>devel.xml</filename>, that you created for this department. And, in the rule
      for the sales department, you would add a link to the profile, called
      <filename>sales.xml</filename>, that you created for the sales department.
    </para>
-->

    <section id="rulesfile">
      <title>Rules File explained</title>
   
      <example>
	<title>
	  Simple rules file
	</title>		

	<para>
	  The following simple example illustrates how the rules file is used
	  to retrieve the configuration for a client with known hardware.
	</para>
	<screen>
<![CDATA[
<?xml version="1.0"?>
<!DOCTYPE autoinstall SYSTEM "/usr/share/autoinstall/dtd/rules.dtd">
<autoinstall xmlns="http://www.suse.com/1.0/yast2ns" xmlns:config="http://www.suse.com/1.0/configns">
  <rules config:type="list">
    <rule>
       <disksize>
            <match>/dev/hdc 1000</match>
            <match_type>greater</match_type>
       </disksize>
       <result>
            <profile>machine1.xml</profile>
            <continue config:type="boolean">false</continue>
        </result>
    </rule>
    <rule>
       <disksize>
            <match>/dev/hda 1000</match>
            <match_type>greater</match_type>
       </disksize>
       <result>
            <profile>machine2.xml</profile>
            <continue config:type="boolean">false</continue>
        </result>
    </rule>
  </rules>
</autoinstall>
]]>
	    </screen>

	  </example>	 
      <para>
	The last example defines 2 rules and provides a different profile for
	every rule. The rule used in this case is
	<emphasis>disksize</emphasis>. After parsing the rules file, &yast2;
	attempts to match the system being installed to the rules in the 
	<filename>rules.xml</filename> file in the following order: first rule through the
	last rule. A rule match occurs when the system being installed matches
	all of the system attributes defined in the rule. As soon as a system
	matches a rule, the result resource is added to the
	stack of profiles  &autoyast; will be using to create the final
	profile.  The <emphasis>continue</emphasis> property tells &autoyast; if it should
        continue with other rules or not after a match has been found. 
      </para>
      <para>
	If the first rule does not match,  next rule in the list is examined
	until a match is found.
      </para>
      <para>
	Using the <emphasis>disksize</emphasis> attribute, you can
	provide different configurations for different hard drives with
	different size. First rule checks if the device
	<emphasis>/dev/hdc</emphasis> is available and if it is greater than 1
	GB in size using the <emphasis>match</emphasis> property. 
      </para>
    
      <para>
	A rule must have at least one attribute to be matched. If you need
	to check more attributes, i.e. memory or architectures, you can add
        more attributes in the rule resource as shown in the next example.
      </para>
      <example>
	<title>
	  Simple rules file
	</title>		

	<para>
	  The following simple example illustrates how the rules file is used
	  to retrieve the configuration for a client with known hardware.
	</para>
	<screen>
<![CDATA[
<?xml version="1.0"?>
<!DOCTYPE autoinstall SYSTEM "/usr/share/autoinstall/dtd/rules.dtd"> 
<autoinstall xmlns="http://www.suse.com/1.0/yast2ns" xmlns:config="http://www.suse.com/1.0/configns">
  <rules config:type="list">
    <rule>
       <disksize>
            <match>/dev/hdc 1000</match>
            <match_type>greater</match_type>
       </disksize>
       <memsize>	    
            <match>1000</match>
            <match_type>greater</match_type>
       </memsize>
       <result>
            <profile>machine1.xml</profile>
            <continue config:type="boolean">false</continue>
        </result>
    </rule>
    <rule>
       <disksize>
            <match>/dev/hda 1000</match>
            <match_type>greater</match_type>
       </disksize>
       <memsize>	    
            <match>256</match>
            <match_type>greater</match_type>
       </memsize>
       <result>
            <profile>machine2.xml</profile>
            <continue config:type="boolean">false</continue>
        </result>
    </rule>
  </rules>
</autoinstall>
]]>
	</screen>

      </example>	 
      <para>
	The rules directory must be located in the same referenced directory
	used with the <emphasis>autoyast</emphasis> keyword on boot time, so
	if the client was booted using<emphasis> autoyast=http://10.10.0.1/profiles/</emphasis>,
	&autoyast; will search for the rules file in 
        <emphasis>http://10.10.0.1/profiles/rules/rules.xml</emphasis>.
      </para>
    </section>
    <section id="rulesstructure">
	<title>Rules file structure</title>
	<para>
	  The <filename>rules.xml</filename> file must have:	  
	</para>
	<itemizedlist>
	  <listitem>
	    <para>At least one rule</para>
	  </listitem>
	  <listitem>
	    <para>It must have the name <filename>rules.xml</filename></para>
	  </listitem>
	  <listitem>
	    <para>It must be located in the directory
	      <emphasis>rules</emphasis> in the profile repository</para>
	  </listitem>

	  <listitem>
	    <para>At least one attribute to match in the rule</para>
	  </listitem>
	</itemizedlist>
    </section>
  
    <section id="ruleattributes">
      <title>Predefined System Attributes</title>
	<para>
	  The following table lists the predefined system attributes you can
	  match in the rules file.
	</para>
	<table frame='top'>
	  <title>System Attributes</title>
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Attribute</entry>
		<entry>Values</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>hostaddress</entry>
		<entry>IP address of host</entry>
		<entry>This attribute must always match exactly</entry>
	      </row>
	      <row>
		<entry>domain</entry>
		<entry>Domain name of host</entry>
		<entry>This attribute must always match exactly</entry>
	      </row>
	    <row>
		<entry>network</entry>
		<entry>network address of host</entry>
		<entry>This attribute must always match exactly</entry>
	      </row>
	      <row>
		<entry>mac</entry>
		<entry>MAC address of host</entry>
		<entry>This attribute must always match exactly. (MAC addresses
		to be matched should be  in the form <emphasis>0080C8F6484C</emphasis></entry>
	      </row>
	      <row>
		<entry>linux</entry>
		<entry>Number of installed Linux partitions on the system</entry>
		<entry>This attribute can be 0 or more</entry>
	      </row>
	      <row>
		<entry>others</entry>
		<entry>Number of installed non-Linux partitions on the system</entry>
		<entry>This attribute can be 0 or more</entry>
	      </row>
	      <row>
		<entry>xserver</entry>
		<entry>X Server needed for graphic adapter</entry>
		<entry>This attribute must always match exactly</entry>
	      </row>
	      <row>
		<entry>memsize</entry>
		<entry>Memory available on host in MByes</entry>
		<entry>All match types are available</entry>
	      </row>
	      <row>
		<entry>totaldisk</entry>
		<entry>Total disk space available on host in MBytes</entry>
		<entry>All match types are available</entry>
	      </row>
	      <row>
		<entry>haspcmica</entry>
		<entry>System has PCMCIA (i.e Laptops)</entry>
		<entry>Exact match required, 1 for available PCMCIA or 0 for none</entry>
	      </row>
	      <row>
		<entry>hostid</entry>
		<entry>Hex representation of IP address</entry>
		<entry>Exact match required</entry>
	      </row>
	      <row>
		<entry>arch</entry>
		<entry>Architecture of host</entry>
		<entry>Exact match required</entry>
	      </row>
	      <row>
		<entry>karch</entry>
		<entry>Kernel Architecture of host (i.e. SMP kernel, Athlon Kernel)</entry>
		<entry>Exact match required</entry>
	      </row>
	      <row>
		<entry>disksize</entry>
		<entry>Drive device and size</entry>
		<entry>All match types are available</entry>
	      </row>
	      <row>
		<entry>product</entry>
                <entry>The hardware product name as specified in SMBIOS</entry>
		<entry>Exact match required</entry>
	      </row>
	      <row>
		<entry>product_vendor</entry>
                <entry>The hardware vendor as specified in SMBIOS</entry>
		<entry>Exact match required</entry>
	      </row>
	      <row>
		<entry>board</entry>
                <entry>The system board name as specified in SMBIOS</entry>
		<entry>Exact match required</entry>
	      </row>
	      <row>
		<entry>board_vendor</entry>
                <entry>The system board vendor as specified in SMBIOS</entry>
		<entry>Exact match required</entry>
	      </row>
	      <row>
		<entry>custom1-5</entry>
		<entry>Custom rules using shell scripts</entry>
		<entry>All match types are available</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
    </section>
  </section>
  
  <section id="classes">
    <title>Classes</title>
    <para>
      You can assign a system to different classes which can be defined in the
      control file. Unlike rules, classes have to be configured in the control
      file and represent a configuration which is typical for a group of
      systems. 
    </para>
    
    <para>
      Using the configuration management system, you can define a set of
      classes. The class definition consists  of the following variable for each class:
    </para>
    <itemizedlist>
      <listitem>
	<para>	        
	  Name: Class name
	</para>
      </listitem>
      <listitem>
	<para>	    
	  Descriptions: Class description
	</para>
      </listitem>
      <listitem>
	<para>	        
	  Order: Order (or priority) of the class in the stack of migration
	</para>
      </listitem>
    </itemizedlist>
    <figure>
      <title>Defining Classes</title>
      <mediaobject>&cms-class-definitions;</mediaobject>	  
    </figure>
    <para>
      You can create as many classes as you need, however it is
      recommended to keep the set of classes as small as possible to keep the
      configuration system concise. As an example, the following set of
      classes can be used:
    </para>
    <itemizedlist>
      <listitem>
	<para>
	  site: Classes describing a physical location or site.
	</para>
      </listitem>
      <listitem>
	<para>
	  machine: Classes describing a type of machine or make
	</para>
      </listitem>
      <listitem>
	<para>
	  role: Classes describing the function of the machine to be
	  installed
	</para>
      </listitem>
      <listitem>
	<para>
	  group: Classes describing a department or a group within a site
	  or a location.
	</para>
      </listitem>
    </itemizedlist>

    <para>
      A  file saved in a class directory can have the same syntax and format as a
      regular control file but  represents a subset of the configuration. For example,
      to create a new control file  for a special computer with a specific network
      interface, only the resource in the control file, which controls
      the configuration of the network is needed. Having multiple network
      types, you can merge the one needed for a special type of hardware
      with other class files and create a new control file which suits
      the system being installed.
    </para>

  </section>

  <section id="mixinfrulesclasses">
    <title>Mixing Rules and Classes</title>
    <para>
      It is possible to mix rules and classes during an auto-installation
      session. For example you can identify a system using rules which contain
      class definitions in them. The process is described in the figures
      <quote><link linkend='rulesflow'
	  endterm="rulesflow.title"></link></quote>.
    </para>
    <para>
      After retrieving the rules and merging them, the generated control file
      is parsed and the presence of class definitions is checked. If classes
      are defined, then the class files are retrieved from the original
      repository and a new merge process is initiated.
    </para>
  </section>
</chapter>

      <!--
       Local Variables:
       mode: xml
       sgml-parent-document: ("autoyast2.xml" "book" "chapter")
       End:
      -->
