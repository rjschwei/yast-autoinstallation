<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/xml/db41xml/docbookx.dtd"[]>

  <article>
  <articleinfo>    
    <title>AutoYaST Configuration Management System</title>
    <author>
      <firstname>Anas</firstname>
      <surname>Nashif</surname>
    </author>
    <author>
      <firstname>Uwe</firstname>
      <surname>Gansert</surname>
    </author>
  </articleinfo>
  <section>
    <title>Introduction</title>
    <para>
      The plugin-like design has the following advantages:
    </para>
    <itemizedlist>
      <listitem>
	<para>
	  New Run-time module can be integrated automatically in AutoYaST,
	  thus new features in YaST2 mean new features in the auto-installer.
	</para>		  
      </listitem> 
      <listitem>
	<para>
	  Only installed run-time modules are offered and used to autoinstall
	  the system. This  allows the integration of speciality run-time modules which are
	  only present on business products for example.
	</para>
      </listitem>
      <listitem>
	<para>
	  Code which is relevant to one run-time configuration module is kept in one place
	  instead of maintaining it in different modules.
	</para>
      </listitem>
    </itemizedlist>      
  </section>
  <section>
    <title>The run-time module interface in AutoYaST</title>
    <para>The new interface (AKA _auto.ycp client) is similar to the proposal
      structure and consists of functions that can be accessed using arguments. All the dialog code has been moved to
      autoyast to simplify the interface and to provide  a common user interface for
      all modules appearing in the autoyast configuration system.
    </para>
    <para>
      The interface of a run-time configuration module in AutoYaST has the follwoing
      components:	
    </para>
    <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Summary Area,</emphasis>: Contains a summary of the consifguration with the
	  values if available. If values where not configured, the phrase
	  <emphasis>'Not configured yet'</emphasis> is used, which is available from the summary module.
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Configuration Button</emphasis>: A button which calls the module in auto mode
	  (<emphasis>&lt;module name&gt;_auto.ycp</emphasis>).
	</para>	  
      </listitem>
      <listitem>
	<para>
	  <emphasis>Reset Button</emphasis>: A button for resetting the
	  configuration data. This will delete only data in the running module.
	</para>
      </listitem>
    </itemizedlist>
    <para>
      The summary area is filled with data from the <emphasis>Summary</emphasis> function in the
      module controling the configuration. (i.e
      <emphasis>NIS::Summary()</emphasis> in the NIS package).
    </para>      
  </section>
  <section>
    <title>Run-time modules in <emphasis>auto</emphasis> mode</title>
    <para>
      The &lt;module name&gt;_auto.ycp client accepts 2 arguments:
    </para>
    <itemizedlist>
      <listitem>
	<para>
	  Function
	</para>
      </listitem>
      <listitem>
	<para>
	  Configuration Data
	</para>
      </listitem>      
    </itemizedlist>
    <para>The following functions are needed to make any module work in AutoYaST:</para>
    <itemizedlist>
      <listitem>
	<para>
	  <emphasis>Import:</emphasis></para>
	<para>
	  Import existing data into the module, usually done only once at the beginning.
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Summary:</emphasis></para>
	<para>
	  To provide  a brief summary of the configuration.
	  Calls &gt;Module&lt;::Summary()
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Reset:</emphasis></para>
	<para>
	  Resets the configuration. It returns empty values but it also can return
	  default values, depending on the module.
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Change:</emphasis></para>
	<para>
	  This function starts the widget sequence
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Write</emphasis></para>
	<para>
	  Write the configuration without displaying any widgets and popups and
	  without restarting any services etc.
	  Calls &lt;Module&gt;::Write (and sets &lt;Module&gt;::write_only true)
	</para>
      </listitem>
      <listitem>
	<para>
	  <emphasis>Export:</emphasis></para>
	<para>
	  Returns the current configuration
	  Calls &lt;Module&gt;::Export
	</para>
      </listitem>     
      <listitem>
	<para>
	  <emphasis>Packages:</emphasis></para>
	<para>
	  Returns a map with two key/value pairs. First key is
	  <emphasis>install</emphasis> which has a list as the value. the list
	  contains packages that are needed for the service configured by the
	  module to work. This can be a static list of packages or a dynamic
	  list depending on the configuration. The second key is
	  <emphasis>remove</emphasis> which contains packages that should be
	  removed to avoid conflicts with other packages. the packages in
	  <emphasis>remove</emphasis> are normally determined dynamically,
	  depending on the configuration.
	  
	</para>
	<para>
	  The function can either return a map directly or it can call a module
	  function &lt;Module&gt;::AutoPackages().
	</para>
      </listitem>      
    </itemizedlist>
    
    <para>
      The following example shows &lt;module name&gt;_auto.ycp with the changes
      needed for the new behaviour. 
    </para>
    <example>
      <title>XXpkgXX_auto.ycp (XXpkgXX = module name)</title>
      <programlisting>
	<![CDATA[
	/**
	* @param function to execute
	* @param map/list of XXpkgXX settings
        * @return map edited settings, 
        * Summary or boolean on success depending on called function
	* @example map mm = $[ "FAIL_DELAY" : "77" ];
	* @example map ret = WFM::CallFunction ("XXpkgXX_auto", [ "Summary", mm ]);
	*/

	{

	textdomain "XXpkgXX";

	y2milestone("----------------------------------------");
	y2milestone("XXPkgXX auto started");

	import "XXPkgXX";
	include "XXpkgXX/wizards.ycp";

	any ret = nil;
	string func = "";
	map param = $[];

	/* Check arguments */
	if(size(Args()) > 0 && is(Args(0), string)) {
	func = WFM::Args(0);
	if(size(Args()) > 1 && is(Args(1), map))
	param = WFM::Args(1);
	}
	y2debug("func=%1", func);
	y2debug("param=%1", param);

	/* Create a  summary*/
	if(func == "Summary") {    
	ret = select(XXPkgXX::Summary(), 0, "");
	}
	else if (func == "Import") {
	ret = XXPkgXX::Import($[]);
	return ret ;
	}

	/* Reset configuration */
	else if (func == "Reset") {
	XXPkgXX::Import($[]);
	ret = $[];
	}
	/* Change configuration (run AutoSequence) */
	else if (func == "Change") {
	ret = XXPkgXXAutoSequence();
	}
	/* Return required packages */
	else if (func == "Packages") {
	ret = XXPkgXX::AutoPackags();
	}
	/* Return actual state */
	else if (func == "Export") {
	ret = XXPkgXX::Export();
	}
	/* Write given settings */
	else if (func == "Write") {
	import "Progress";
	XXPkgXX::write_only = true;
	Progress::off();
	ret = XXPkgXX::Write();
	Progress::on();
	return ret;
	}
	/* Unknown function */
	else {
	y2error("Unknown function: %1", func);
	ret = false;
	}

	y2debug("ret=%1", ret);
	y2milestone("XXPkgXX auto finished");
	y2milestone("----------------------------------------");

	return ret;

	/* EOF */
	}




	]]>
      </programlisting>
    </example>
  </section>
  <section>
    <title>Module functions needed for Auto-Install</title>
    <para>The follwoing is the list of function that should be available with
      the modules to provide the functionality needed in the AutoYaST.
    </para>
    <refentry>
      <refnamediv>
	<refname>AutoPackages()</refname>
	<refpurpose>Return needed packages for module to work</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Description</title>
	<para>
	  This function return a map of lists which contain packages to be
	  installed or removed during installation (second stage).	  
	</para>

      </refsect1>
      
      <refsect1>
	<title>Returns</title>
	<para>
	  For example, the function can return the following structure:
	</para>
	<screen>
	  $[
	  "install": ["pkg1", "pkg2"], 
	  "remove": ["pkg3"]
	  ]
	</screen>
      </refsect1>
    </refentry>
    <refentry>
      <refnamediv>
	<refname>Import()</refname>
	<refpurpose>Imports settings from arguments</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Description</title>
	<para>This function imports settings from arguments and sets the module
	  variables. The <emphasis>Import</emphasis> function should bring the
	  module to a state where the data imported is enough for the module to
	  write (See Write()) a usable configuration.
	</para>

      </refsect1>
      
      <refsect1>
	<title>Returns</title>
	<para>Import() return false if some of the required keys are missing in the
	  imported map. If the imported data is empty, it returns true and
	  starts the module using default values.
	</para>
      </refsect1>
    </refentry>
    <refentry>
      <refnamediv>
	<refname>Export()</refname>
	<refpurpose>Exports configured data to calling module</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Description</title>
	<para>Exports configured data to calling module. This function also
	  converts the internal variables to unique and human readable
	  variables which can be used in the control file needed for the
	  auto-installation. It is not allowed to export <emphasis>maps</emphasis> with configured
	  data as the keys. Configured data must be the value of a variable.</para>
      </refsect1>
      <refsect1>
	<title>Example</title>
	<example>
	  <title>Export()</title>
	  <programlisting>
	    <![CDATA[
	    global define map Export () ``{
	    return $[
	    "start_nis": start,
	    "nis_servers": servers,
	    "nis_domain": domain,
	    "start_autofs": _start_autofs,
	    ];
	    }
	    ]]>
	  </programlisting>
	</example>
      </refsect1>
      <refsect1>
	<title>Returns</title>
	<para>This function returns a map of the configuration data.</para>
      </refsect1>
    </refentry>

    <refentry>
      <refnamediv>
	<refname>Write()</refname>
	<refpurpose>Write or commit configured or imported data</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Description</title>
	<para>Commit configured data. This function is also used in normal
	  operation mode and should not be used to write configuration in
	  auto-installation mode. Instead, use<emphasis> WriteOnly()</emphasis>
	  or set the global variable <emphasis>write_only</emphasis> to true
	  before writing.
	</para>
	<para>
	  during the write process, check for the global boolean variable
	  <emphasis>write_only</emphasis> which should be used to prevent the
	  module from restarting services and showing GUI components during
	  autoinstallation which might interfere with the installation widgets.
	</para>
	
      </refsect1>
    </refentry>

  </section>
  <section>
    <title>Configuration file</title>
    
    <para>
      When AutoYaST  is invoked, it  checks for the desktop files in
      <filename>/usr/share/applications/YaST2</filename> and evaluates them to
      later include them in the configuration interface. AutoYaST uses the same configuration file used for the YaST2
      Control Center with some additional enhancements.
    </para>
    <para>
      The following is an example of the configuration file for the NIS module:
    </para>
    <example>
      <title>Auto-Install Configuration file for NIS</title>
      <programlisting>
[Desktop Entry]
Type=Application
Categories=Qt;X-SuSE-YaST;X-SuSE-YaST-Net_advanced;

X-KDE-ModuleType=Library
X-KDE-RootOnly=true
X-KDE-HasReadOnlyMode=true
X-KDE-Library=yast2
X-SuSE-YaST-Call=nis

X-SuSE-YaST-Group=Net_advanced
X-SuSE-YaST-Argument=
X-SuSE-YaST-RootOnly=true
X-SuSE-YaST-AutoInst=all
X-SuSE-YaST-Geometry=
X-SuSE-YaST-SortKey=
X-SuSE-YaST-AutoInstClonable=true

Icon=nis_client
Exec=/sbin/yast2 nis

Name=NIS Client
GenericName=Configure NIS client


      </programlisting>
    </example>
    <para>In addition to the keywords from the last example, AutoYaST also evaluates
      the following keywords:</para>

    <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInst</refname>
	<refpurpose>Is the module compatible with the
	  AutoYaST and can Import/Export configurations?</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values:</title>
	<para>
	  <itemizedlist>
	    <listitem>
	      <para><emphasis>all</emphasis>: Full auto-installation support,
		including  the AutoYaST interface and writing configurations
		during autoinstall. </para>	
	    </listitem>
	    <listitem>
	      <para><emphasis>write</emphasis>: Write only support. No
		integration into AutoYaST interface. </para>	
	    </listitem>     
	    <listitem>
	      <para><emphasis>configure</emphasis>: Configuration only support.
		Normally used only with parts related to installation like
		partitioning and general options which have no run-time module
		with support for auto-installation. Data is written using the
		common installation process and modules available in YaST2</para>
	    </listitem>    

	  </itemizedlist>  
	</para>
      </refsect1>
    </refentry>
    <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstPath</refname>
	<refpurpose>Path in the control file</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values:</title>
	<para>	configure or install: All run-time configuration modules are
	  contained in the <emphasis>configure</emphasis> resource. Only
	  configuration data directly touching the installation of a system are
	  contained in the <emphasis>install</emphasis> resource.</para>
      </refsect1>
    </refentry>
    <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstClient</refname>
	<refpurpose>Name of the client to call</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para>	Name of the client to be called by AutoYaST</para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para>&lt;module name&gt;_auto</para>
      </refsect1>
    </refentry>
    <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstDataType</refname>
	<refpurpose>Data type of configuration section</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para><emphasis>map</emphasis> or <emphasis>list</emphasis></para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para>map</para>
      </refsect1>
    </refentry>
     <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstResource</refname>
	<refpurpose>Name of the resource in the Profile</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para>string</para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para></para>
      </refsect1>
    </refentry>   
     <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstRequires</refname>
	<refpurpose>What modules are required before this module is run. </refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para>comma delimited list of required modules</para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para></para>
      </refsect1>
    </refentry>   

<!-- merging stuff -->

    <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstMerge</refname>
	<refpurpose>Multiple sections in the profile can be handled by one module</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para>comma delimited list of sections to merge (see also X-SuSE-YaST-AutoInstMergeTypes)</para>
	<para>The Users module for example handles also groups and user_defaults.</para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para></para>
      </refsect1>
    </refentry>   
    <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstMergeTypes</refname>
	<refpurpose>Which datatypes are the section of that will be merged to be handled by one module</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para>comma delimited list of datatypes (list or map) for the sections from X-SuSE-YaST-AutoInstMerge</para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para></para>
      </refsect1>
    </refentry>   

<!-- clone stuff -->

    <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstClonable</refname>
	<refpurpose>is this module able to clone the actual system</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para>a boolean (true,false)</para>
	<para>If this is true, the module will appear in the list of modules you can choose from during the cloning of the actual system. Your module will Read() and Export() it's data from the actual system then.</para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para>false</para>
      </refsect1>
    </refentry>   

<!-- schema stuff -->

    <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstSchema</refname>
	<refpurpose>base name of schema file, including the rnc
	extension (Relax NG compact syntax)</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para>string</para>
	<para></para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para></para>
      </refsect1>
    </refentry>

    <refentry>
      <refnamediv>
	<refname>X-SuSE-YaST-AutoInstOptional</refname>
	<refpurpose>is the element optional in the schema</refpurpose>
      </refnamediv>
      <refsect1>
	<title>Values</title>
	<para>a boolean (true,false)</para>
	<para>Does this element has to appear in the profile? Unless you have a very basic module, this is always true.</para>
      </refsect1>
      <refsect1>
	<title>Default Value</title>
	<para>true</para>
      </refsect1>
    </refentry>


  </section>
  <section>
    <title>Conventions for module Writers</title>
    <section>
      <title>Exported Data</title>
      <itemizedlist>
	<listitem>
	  <para><emphasis>Type of exported data</emphasis>: </para>
	  <para>Modules should only export data which is normally selected or
	    entered by the user in normal module operation. No computed or
	    automatically probed data should be exported.</para>
	</listitem>
	<listitem>	  
	  <para><emphasis>Use Namespaces</emphasis></para>
	  <para>Exported variables should have a unique name when possible and
	    when  general terminology is being used. To avoid conflicts and confusion,
	    use a name space identifier with common words. For example, if  a
	    module should export the variable name
	    <emphasis>options</emphasis>, it is better to export<emphasis> &lt;module
	      name&gt;.options</emphasis> to avoid confusion with other modules using
	    <emphasis>options</emphasis>, which is very common in configurations.	    
	  </para>	  
	</listitem>
	<listitem>
	  <para><emphasis>Lower case variables</emphasis></para>
	  <para>To have a common and unified look of the control file, please
	    use lower case variables when exporting the configuration data.</para>
	</listitem>
	<listitem>
	  <para>The structure of the exported data should be readable and not
	    unnecessarly complex.</para>
	</listitem>
	<listitem>
	  <para>Avoid using configuration data as the key in a map key/value
	    pair. The key of the pair must always contain the variable name,
	    rather than it's contents</para>
	</listitem>
      </itemizedlist>
      
    </section>    

    <section>
      <title>YaST2 Module Types</title>
      <para>
	YaST2 configuration modules and in relation with AutoYaST can be put
	into three categories:	
      </para>      
      <orderedlist>
	<listitem>
	  <para>Simple modules which mormally only change sysconfig variable
	    and have simple configuration data structure. (i.e. mail, nis,
	    ldap, etc.)
	  </para>
	  <para>
	    This category needs no special attention and is easy to integrate with
	    the AutoYaST. 
	  </para>
	</listitem>
	<listitem>
	  <para>Simple modules dealing with hardware configuration (i.e. network,
	    sound, printer etc.)
	  </para>
	  <para>
	    These modules need to be able to
	    read and autodetect hardware data during installation if no hardware
	    data is specified in the control file. The behaviour of this type of
	    modules up to 8.1 was to import data and write it wihtout actually
	    reading anything from the system.
	  </para>
	  <para>
	    An additional step has to be added between the import and the
	    write, where hardware data is read and imported into the module. In
	    some case this is simply done by calling the Read function the module.
	  </para>
	</listitem>
	<listitem>
	  <para>Modules for management of complex configuration files
	    (i.e. inetd, sysconfig, runlevel, users, bootloader)
	  </para>
	  <para>
	    This class of modules is much more complex and requires adaptation
	    and special attention. AutoYaST expects that only new and modified
	    entries will be exported and not the whole configuration tree. For
	    example when a user enables a service in inetd, only this service
	    is exported. A user should be able to add new services which are
	    not available in the default configuration file too.
	  </para>
	</listitem>
      </orderedlist>           	
    </section>
    <section>
      <title>Module behaviour</title>
      <para>
	In configuration mode for auto-installation, modules <emphasis>should
	  not</emphasis>(configuration system is the machine where the control
	file is being created):
	<itemizedlist>
	  <listitem>
	    <para>Read any data from the configuration system</para>
	  </listitem>
	  <listitem>
	    <para>Probe or detect hardware on the configuration system</para>
	  </listitem>
	  <listitem>
	    <para>Change configuration data on the configuration system</para>
	  </listitem>
	  <listitem>
	    <para>Offer a link to other modules (i.e. calling the NIS module
	      from the users module)</para>
	  </listitem>

	  <listitem>
	    <para>Check if a needed package is installed on the configuration system.</para>
	  </listitem>
	  
	</itemizedlist>
      </para>
    </section>
  </section>
  </article>

